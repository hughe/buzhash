package buzhash

// A 64 bit variant of buzhash.  Generated by Hugh using by search and
// replace s/32/64/g, s/31/63/g.  I needed a larger range of possible
// values.

import (
	"bytes"
	"encoding/binary"
)

// 256 random uint64's to hash a single byte
//
// Generated using http://play.golang.org/p/3BjRXtVBWh:
//
// package main

// import (
// 	"fmt"
// 	"math/rand"
// )

// func main() {
// 	for i := 0; i < 256; i++ {
// 		// Int63 only gives you 63 bits, shift in another bit to make 64.
// 		fmt.Printf("0x%016x,\n", uint64(rand.Int63())|(uint64(rand.Int31n(2))<<63))
// 	}

// }

var bytehash64 = [256]uint64{
	0xcd65822107fcfd52, 0xd5104dc76695721d, 0x365a858149c6e2d1, 0x0866cb397916001e,
	0x0c697f48392907a0, 0xc1f27cc6f3875d04, 0x9b6cffa2ba517936, 0x28b621587cb3ad0b,
	0xa43a768b7c4e0b68, 0x56ec3f2525632186, 0x1a02070f169c1121, 0x490bd268b68e6a3f,
	0xa584c47f2cdf5b8a, 0x6054502fc5d6d268, 0xeec34c367674cb74, 0x430c8b35bb9457d8,
	0x944419db794209ff, 0x7cd4b7a55a25e0cb, 0xcc22b02936d4ff9b, 0x589442fd5ad145f4,
	0x162d968d3f71f8cb, 0xc5a6e3cafccae224, 0xb629d9f17d9e8fbc, 0x207403def63a5b6f,
	0xe4f1017fbc897d06, 0xf0b5a315724c7af1, 0xf27a71f52257bb7d, 0xfd0b9ca8be8e9981,
	0x1c73fac825416fed, 0x9ee9f7676678e7aa, 0x7767830356aa6b86, 0x6688f8bd3e99b0a8,
	0x176a156ae58348b0, 0x72d0a1e9406aec9d, 0x7d4d8e9fa5ead0bd, 0x0ba08e4b738b6829,
	0x76a780ea967cd710, 0x2c89c16725fd3d7f, 0xdaff01c926fbf29b, 0x5322787c2bf3394b,
	0xe0bed31f1cb9e6c6, 0x90b92d0169a39144, 0xf2bb5389421657ff, 0xdc4e91e98b02c917,
	0x0af2560383d17909, 0x4fb58fbeaf635d47, 0x9e503382be14186f, 0x97f7ae24e9174548,
	0xd065855807b73658, 0x2402a18da250bf34, 0xb7ab3641fe3dea79, 0xc66b36dbc9b344e9,
	0x5d55cb471941e52a, 0x8010d6326b40eabc, 0x3332aafe336eacca, 0xcd4f278a67149b9c,
	0x03cc44bf5a5ffefb, 0x805d29286f00f02b, 0xcb7fafc3545836c4, 0x685f325712f4128d,
	0x3aae3e3e4a305605, 0x835ca80d72521a90, 0x1ff5f26283efc6c6, 0x1facfc5dc1540864,
	0xcbdb185b70ab53ba, 0xd8cfb024878d4063, 0x4504d6353cb62f07, 0xe01900fb4ffbf3a9,
	0x606796b83f190476, 0xad89c820f5c353cf, 0x9dac9b582d230176, 0x3fcb626c3f1d7427,
	0x83398e40b01aa47d, 0x4b70e7ac7417bf38, 0x493a23eb55ece0ea, 0xb4b4a3c813d346b5,
	0x3eecfdbc6db30e37, 0xe60aedf1a6e222f5, 0x643a7d712e166bdf, 0x10b166a221898f34,
	0xdeb29c7719af53ba, 0x0c97d70a133c9673, 0x8cc3f10e0f212551, 0x09c09a3e6f241c57,
	0x146f70ff3be70cb0, 0x294b4e8e20f31127, 0x4911aa87289cbd2c, 0x57930cf840a79c3b,
	0xc322cee10365790c, 0xdbb1f57b0bb131e8, 0x81a44786139efcca, 0x8c8c4694a54af747,
	0xe9c93fb09f6c47ac, 0x2c1283b654043a66, 0x1bb55397b4926431, 0x33770eb58f0d2558,
	0x15974b9d7f803594, 0x69f98c4033fe2656, 0x076a20af6b41292d, 0x34ad5ac882093298,
	0x63efbff5b2d5a113, 0x86d8e96f5b8e56a9, 0x2018fa6e04f9ce92, 0x7ca82947a67e52b1,
	0x02c19e7792417fc3, 0x8be67230b027b7e0, 0x27ebdd8f44c9ab40, 0x3e5ddb0efd7a84af,
	0xd5fe7f03e3abff4a, 0x733c374d736e41cc, 0xa8dfd8d37b3ccebc, 0xb3415dbd315ae6af,
	0xd290a23119ea0f2f, 0x2b77e80684a6bfdc, 0x1e3ffa8aa44a03a4, 0x04939bb8b580c8ba,
	0xd01b6a22b648e604, 0x0945fcdd893a310f, 0xf09ec18437f5198b, 0x6c7ae37ae39d02db,
	0x9fb95e8cca599392, 0x899ad1bdc176163d, 0x508df0dcf9f95ede, 0xd0e57d0f8a928585,
	0x81e5dcfd887953e8, 0x88cd00c4e533e9a3, 0xd3189b251dba77ae, 0x6adaea4753b428d7,
	0x54a888203391860a, 0x27beccfcba9075b0, 0xfbc9bf542b517f2b, 0xa79f489bc56ba9c3,
	0x356aeee5fdde63b1, 0xb40ff35e51e90a1f, 0x7aa585e696d511e1, 0x655584aa5403510d,
	0x81f175c897a14c51, 0xf3cfb52e3298237e, 0x857e74d4b80f63d4, 0x2c86a526ee438107,
	0x6b8365a824bf7034, 0x8feb24ce99aa99ff, 0xeadf8f5522164965, 0x00fbb2a14ccdd7af,
	0x2f64ed37e9a7b972, 0xd254827163240d09, 0xe5439851da458093, 0xac66091f323f491a,
	0x693a570dd2d99eb9, 0xccb265b33b61e4f4, 0x34f038c8cd856313, 0xf4afc208a0ac1074,
	0x1d4d2be64ed98e0f, 0x2ce5df27e9317c1f, 0xa6e2fcfa16fea4d3, 0xd5f494fe4fffba7f,
	0x7b4826e2d3aa4530, 0x676a9d03e5dc69d1, 0x7950358b44e12d33, 0xfa04620310c35d10,
	0x973e5e6e09d0c910, 0x6a661b336077ccd0, 0x6d7acf370641dfb5, 0x2301e04cf3300698,
	0x74730ec5cb16b239, 0xbfd3302cb8d86b50, 0x7cea22c17e65a845, 0x05c24155b9170e16,
	0x79d80f8784e7f8e3, 0x4494cca9136663df, 0xeebe0de7c0f8f4f6, 0x4a0df4baa53a0341,
	0xc67a93c930a03c8e, 0x414345252574f921, 0xbed256987db903e7, 0x21994b45cb188bde,
	0x2f8cdfe5e2e4da00, 0xb5375c4ca0a6fb45, 0x736888b427bce82c, 0xa30ff59da1d7abbf,
	0xed7f55666529f937, 0x7e9be16159cdf006, 0x95e18f4099adb897, 0x44482319682c1dde,
	0x6823be14ff09ef3c, 0x20ec2d5fb4589140, 0x2ae45f4973ff40d6, 0x009fe6955b23d37e,
	0x1d62aad7bd1eae1f, 0xf9978c8884bc9335, 0x7b37451320249dab, 0x5b38874a2a2340e1,
	0x342a0313380457d7, 0x2c79d81547f02daa, 0xcc7d0ca62520ac90, 0x6a9b054afe554373,
	0x77e6089b2f436dc4, 0xdc33383c18aca777, 0x399ea4d12f0175f9, 0xbc7a9e9c04ec53b4,
	0xae60e0ba4a43643f, 0x06208ccef90a5b41, 0x60cb7ec70332fa39, 0x1c49b0bcf930b4e0,
	0xb207200fe80c1269, 0x9328e4d4457b9829, 0x61fece1535d95dc3, 0x3a4bfceb81e23579,
	0x0a7df9b9f1205ae5, 0xa218cc7166a83987, 0x8cae54ddc325f819, 0x9460c84bd3dadc65,
	0xd0d4397dca20e3f9, 0x7bd7363f2f8357f0, 0xab4984a40b8d54db, 0x6b321559b47697c6,
	0xc048c57dfab88cbe, 0xbb44e0dfb59c1fcb, 0xdf3dc58438baf202, 0x1fcc20aeaed4e9a8,
	0xb63bdfa8f2d8b892, 0x54139a8ecad480ca, 0x51825d31521f7308, 0x3184acf280b45806,
	0x102cb51337fe4f92, 0x41738febb48eaa7d, 0xff4f42ed0e150941, 0xdd18c9ed03aabae5,
	0x41cb8638aab4ddb4, 0xc5d64e9e805321be, 0xa58a577a01a6b56b, 0x1225ce839a88b076,
	0xd0d004da190858f8, 0x802e40e3b63d4fe4, 0x71a32b414b3eb387, 0x4c4f95107709ec27,
	0x6a382511b464c014, 0x08708d7543a5e698, 0xaaf2412a47a6c709, 0x4f3c5d4e5f7684cf,
	0x298df029d6fc440f, 0x8ac6a2c7fd67fe69, 0xd8023c061d0c639f, 0x82d531646eefe2d2,
	0x8a03f4cc4d49461f, 0x9d41f3b098c1293e, 0x22d25dd56b8d471a, 0x54b6d8e314b0255d,
	0x7bffd26a2dfa6ca4, 0x2ea4a948d0f30a66, 0x1a63f3a3979121a6, 0x621a6b7b389f61f3,
	0xa4da37d1240702aa, 0x39e1d17d74a44f97, 0x31cc998f3aca50c1, 0x00f6b13585105e56}

// BuzHash64 implements the hash.Hash64 and hash.Hash32 interface and also has a function to write a single byte.
type BuzHash64 struct {
	state    uint64
	buf      []byte
	n        int
	bshiftn  uint
	bshiftm  uint
	bufpos   int
	overflow bool
}

// NewBuzHash64 generates and initializes a new BuzHash64 object with block size n
func NewBuzHash64(n int) *BuzHash64 {
	rv := new(BuzHash64)
	rv.n = n
	rv.bshiftn = uint(n % 64)
	rv.bshiftm = 64 - rv.bshiftn
	rv.buf = make([]byte, n)
	rv.Reset()
	return rv
}

// HashByte updates the hash with a single byte and returns the resulting sum
func (bh *BuzHash64) HashByte(b byte) uint64 {
	if bh.bufpos == bh.n {
		bh.overflow = true
		bh.bufpos = 0
	}

	state := bh.state

	state = (state << 1) | (state >> 63)

	if bh.overflow {
		toshift := bytehash64[bh.buf[bh.bufpos]]
		state ^= (toshift << bh.bshiftn) | (toshift >> bh.bshiftm)
	}

	bh.buf[bh.bufpos] = b
	bh.bufpos++

	state ^= bytehash64[b]

	bh.state = state
	return state
}

// Write updates the hash with the bytes from slice p
func (bh *BuzHash64) Write(p []byte) (int, error) {
	for _, b := range p {
		bh.HashByte(b)
	}

	return len(p), nil
}

// Sum appends the (little endian) checksum to b
func (bh *BuzHash64) Sum(b []byte) []byte {
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, bh.state)
	hash := buf.Bytes()
	for _, hb := range hash {
		b = append(b, hb)
	}

	return b
}

func (bh *BuzHash64) Reset() {
	bh.state = 0
	bh.bufpos = 0
	bh.overflow = false
}

func (bh *BuzHash64) Size() int {
	return 4
}

func (bh *BuzHash64) BlockSize() int {
	return int(bh.n)
}

func (bh *BuzHash64) Sum32() uint32 {
	return uint32(bh.state)
}

func (bh *BuzHash64) Sum64() uint64 {
	return bh.state
}
